{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"X-LAB Plotting \u2013 Generic Example Implementation Welcome to the Generic Example Implementation for X-LAB Plotting . This repository provides a minimal, fully functional reference implementation that shows how to structure data types, processors, plotters, and workers so they can be discovered and used by the main X-LAB Plotting Manager GUI. If you want a quick overview of what\u2019s here, see What this example provides . If you want to understand how the pieces fit together, see Concepts & architecture . If you want to plug this into the GUI or build your own modules, see Using & extending . This repository only contains the example implementation modules. It is intended to be read, modified, copied, or replaced when creating your own plotting modules.","title":"Home"},{"location":"#x-lab-plotting-generic-example-implementation","text":"Welcome to the Generic Example Implementation for X-LAB Plotting . This repository provides a minimal, fully functional reference implementation that shows how to structure data types, processors, plotters, and workers so they can be discovered and used by the main X-LAB Plotting Manager GUI. If you want a quick overview of what\u2019s here, see What this example provides . If you want to understand how the pieces fit together, see Concepts & architecture . If you want to plug this into the GUI or build your own modules, see Using & extending . This repository only contains the example implementation modules. It is intended to be read, modified, copied, or replaced when creating your own plotting modules.","title":"X-LAB Plotting \u2013 Generic Example Implementation"},{"location":"concepts-and-architecture/","text":"Concepts & Architecture This example implementation is designed to answer a few core questions: How should I define a data class that the GUI can load? How do processors validate and expose observables? How do plotters receive processed data and render figures? What is the minimal amount of code required to create a working implementation? To do that, it uses four main concepts. Data Types Data type: a class that encapsulates raw experimental data and exposes it through a well-defined interface ( DataCore ). In this example: GenericScatterData stores the raw x/y values. It handles loading from CSV or Excel. It exposes observables such as the independent variable, dependent variable, and any labels or metadata. Data Processors Processor: a class that validates observable requests and prepares data for plotters. In this example: ScatterDataProcessor wraps a GenericScatterData instance. It checks that requested observables exist and can be returned. It delegates unit and data access back to the data type. More advanced implementations might compute derived observables here. Plotters Plotter: a class that turns processed data into a visual representation. In this example: ScatterDataPlotter generates simple line / scatter plots. HistogramPlotter visualises distributions. Both demonstrate: how to receive data from a processor how to use PlotterOptions to configure the output how to produce figures that the GUI can display or export Workers (Devices) Worker: a device-specific glue layer that tells the GUI which data types, processors, and plotters to use. In this example: Generic is the worker class. It wires together the GenericScatterData , ScatterDataProcessor , and the plotters. The GUI discovers this worker and uses it to understand what plots are available and how to build them. When you build your own implementation, you typically: Define one or more data types. Optionally define processors for those data types. Define one or more plotters. Create a worker class that wires all of the above together.","title":"Concepts & architecture"},{"location":"concepts-and-architecture/#concepts-architecture","text":"This example implementation is designed to answer a few core questions: How should I define a data class that the GUI can load? How do processors validate and expose observables? How do plotters receive processed data and render figures? What is the minimal amount of code required to create a working implementation? To do that, it uses four main concepts.","title":"Concepts &amp; Architecture"},{"location":"concepts-and-architecture/#data-types","text":"Data type: a class that encapsulates raw experimental data and exposes it through a well-defined interface ( DataCore ). In this example: GenericScatterData stores the raw x/y values. It handles loading from CSV or Excel. It exposes observables such as the independent variable, dependent variable, and any labels or metadata.","title":"Data Types"},{"location":"concepts-and-architecture/#data-processors","text":"Processor: a class that validates observable requests and prepares data for plotters. In this example: ScatterDataProcessor wraps a GenericScatterData instance. It checks that requested observables exist and can be returned. It delegates unit and data access back to the data type. More advanced implementations might compute derived observables here.","title":"Data Processors"},{"location":"concepts-and-architecture/#plotters","text":"Plotter: a class that turns processed data into a visual representation. In this example: ScatterDataPlotter generates simple line / scatter plots. HistogramPlotter visualises distributions. Both demonstrate: how to receive data from a processor how to use PlotterOptions to configure the output how to produce figures that the GUI can display or export","title":"Plotters"},{"location":"concepts-and-architecture/#workers-devices","text":"Worker: a device-specific glue layer that tells the GUI which data types, processors, and plotters to use. In this example: Generic is the worker class. It wires together the GenericScatterData , ScatterDataProcessor , and the plotters. The GUI discovers this worker and uses it to understand what plots are available and how to build them. When you build your own implementation, you typically: Define one or more data types. Optionally define processors for those data types. Define one or more plotters. Create a worker class that wires all of the above together.","title":"Workers (Devices)"},{"location":"using-and-extending/","text":"Using & Extending This Example This repository is intended to be cloned inside the main GUI project directory: ```text X-LAB_Plotting_Manager/ gui/ implementations/ \u2190 this repo","title":"Using & extending"},{"location":"using-and-extending/#using-extending-this-example","text":"This repository is intended to be cloned inside the main GUI project directory: ```text X-LAB_Plotting_Manager/ gui/ implementations/ \u2190 this repo","title":"Using &amp; Extending This Example"},{"location":"what-this-example-provides/","text":"What This Example Provides This implementation demonstrates several minimal but complete building blocks for X-LAB Plotting. 1. A Minimal Data Type GenericScatterData A simple two-column x/y dataset container supporting Excel or CSV inputs, implemented using the core DataCore interface. Use this as a template for defining your own data classes that the X-LAB GUI can load and inspect. 2. A Simple Data Processor ScatterDataProcessor A lightweight processor that validates requested observables and delegates raw data access to the data type. It shows how processors: expose available observables validate requests for observables hand data off to plotters 3. Example Plotters ScatterDataPlotter \u2014 for basic line or scatter-style plots HistogramPlotter \u2014 for quick distribution visualisations These plotters demonstrate how to: integrate with the core Plotter interface consume processed data from a processor expose configuration via PlotterOptions 4. A Device Worker Generic A concrete worker that wires the example data type, processor, and plotters together. This class shows how the main GUI discovers and uses implementations and is the best starting point when wiring up your own device-specific worker.","title":"What this example provides"},{"location":"what-this-example-provides/#what-this-example-provides","text":"This implementation demonstrates several minimal but complete building blocks for X-LAB Plotting.","title":"What This Example Provides"},{"location":"what-this-example-provides/#1-a-minimal-data-type","text":"GenericScatterData A simple two-column x/y dataset container supporting Excel or CSV inputs, implemented using the core DataCore interface. Use this as a template for defining your own data classes that the X-LAB GUI can load and inspect.","title":"1. A Minimal Data Type"},{"location":"what-this-example-provides/#2-a-simple-data-processor","text":"ScatterDataProcessor A lightweight processor that validates requested observables and delegates raw data access to the data type. It shows how processors: expose available observables validate requests for observables hand data off to plotters","title":"2. A Simple Data Processor"},{"location":"what-this-example-provides/#3-example-plotters","text":"ScatterDataPlotter \u2014 for basic line or scatter-style plots HistogramPlotter \u2014 for quick distribution visualisations These plotters demonstrate how to: integrate with the core Plotter interface consume processed data from a processor expose configuration via PlotterOptions","title":"3. Example Plotters"},{"location":"what-this-example-provides/#4-a-device-worker","text":"Generic A concrete worker that wires the example data type, processor, and plotters together. This class shows how the main GUI discovers and uses implementations and is the best starting point when wiring up your own device-specific worker.","title":"4. A Device Worker"},{"location":"api/data/generic_scatter/","text":"Generic Scatter Datatype Bases: DataCore GenericScatterData A lightweight data container class for simple two-column scatter-type datasets. This class derives from DataCore and provides a minimal implementation for reading CSV or Excel files containing paired independent (x) and dependent (y) variables. Overview GenericScatterData is intended for plotters or processors that work with generic x\u2013y data without prescribing specific physical quantities. The class: Stores all raw observable data Exposes four possible observables: label : A string passed during construction. independent : X-axis data (units: \"Independent var (a.u.)\"). dependent : Y-axis data (units: \"Dependent var (a.u.)\"). datetime : Extracted from the filename Attributes label_format : str Datetime formatting string used for timestamp extraction from filenames. str Regular expression pattern for detecting the encoded timestamp in filenames. KeysView Set internally based on raw_data keys. Used by :meth: DataCore.get_data . Usage Notes This class is commonly paired with :class: DataProcessor subclasses and may be used by scatter-based plotters. It is intentionally generic: units and semantic meaning of variables are left to the user or to processing layers. Source code in data\\data_types\\generic_scatter.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class GenericScatterData ( DataCore ): \"\"\" GenericScatterData ================== A lightweight data container class for simple two-column scatter-type datasets. This class derives from `DataCore` and provides a minimal implementation for reading CSV or Excel files containing paired *independent* (x) and *dependent* (y) variables. Overview -------- `GenericScatterData` is intended for plotters or processors that work with generic x\u2013y data without prescribing specific physical quantities. The class: - Stores all raw observable data - Exposes four possible observables: - ``label``: A string passed during construction. - ``independent``: X-axis data (units: \"Independent var (a.u.)\"). - ``dependent``: Y-axis data (units: \"Dependent var (a.u.)\"). - ``datetime``: Extracted from the filename Attributes ---------- label_format : str Datetime formatting string used for timestamp extraction from filenames. dt_pattern : str Regular expression pattern for detecting the encoded timestamp in filenames. _allowed_observables : KeysView Set internally based on ``raw_data`` keys. Used by :meth:`DataCore.get_data`. Usage Notes ----------- This class is commonly paired with :class:`DataProcessor` subclasses and may be used by scatter-based plotters. It is intentionally generic: units and semantic meaning of variables are left to the user or to processing layers. \"\"\" def __init__ ( self , label ): super () . __init__ ( file_reader = read_csv ) self . raw_data = { \"label\" : { \"units\" : \"N/A\" , \"data\" : label }, \"independent\" : None , \"dependent\" : None , \"datetime\" : None , } self . _allowed_observables = self . raw_data . keys () self . label_format = \"%Y_%m_ %d _%H_%M_%S\" self . dt_pattern = '\\d {4} _\\d {2} _\\d {2} _\\d {2} _\\d {2} _\\d {2} ' @with_logging def read_file ( self , filepath : str ): data = self . file_reader ( filepath ) # Assume first two columns are independent and dependent variables if self . raw_data [ 'independent' ] is None : self . raw_data [ 'independent' ] = { \"units\" : \"Independent var (a.u.)\" , \"data\" : data [ '0' ]} if self . raw_data [ 'dependent' ] is None : self . raw_data [ 'dependent' ] = { \"units\" : \"Dependent var (a.u.)\" , \"data\" : data [ '1' ]}","title":"Generic Scatter Datatype"},{"location":"api/data/generic_scatter/#generic-scatter-datatype","text":"Bases: DataCore","title":"Generic Scatter Datatype"},{"location":"api/data/generic_scatter/#data.data_types.generic_scatter.GenericScatterData--genericscatterdata","text":"A lightweight data container class for simple two-column scatter-type datasets. This class derives from DataCore and provides a minimal implementation for reading CSV or Excel files containing paired independent (x) and dependent (y) variables.","title":"GenericScatterData"},{"location":"api/data/generic_scatter/#data.data_types.generic_scatter.GenericScatterData--overview","text":"GenericScatterData is intended for plotters or processors that work with generic x\u2013y data without prescribing specific physical quantities. The class: Stores all raw observable data Exposes four possible observables: label : A string passed during construction. independent : X-axis data (units: \"Independent var (a.u.)\"). dependent : Y-axis data (units: \"Dependent var (a.u.)\"). datetime : Extracted from the filename","title":"Overview"},{"location":"api/data/generic_scatter/#data.data_types.generic_scatter.GenericScatterData--attributes","text":"label_format : str Datetime formatting string used for timestamp extraction from filenames. str Regular expression pattern for detecting the encoded timestamp in filenames. KeysView Set internally based on raw_data keys. Used by :meth: DataCore.get_data .","title":"Attributes"},{"location":"api/data/generic_scatter/#data.data_types.generic_scatter.GenericScatterData--usage-notes","text":"This class is commonly paired with :class: DataProcessor subclasses and may be used by scatter-based plotters. It is intentionally generic: units and semantic meaning of variables are left to the user or to processing layers. Source code in data\\data_types\\generic_scatter.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class GenericScatterData ( DataCore ): \"\"\" GenericScatterData ================== A lightweight data container class for simple two-column scatter-type datasets. This class derives from `DataCore` and provides a minimal implementation for reading CSV or Excel files containing paired *independent* (x) and *dependent* (y) variables. Overview -------- `GenericScatterData` is intended for plotters or processors that work with generic x\u2013y data without prescribing specific physical quantities. The class: - Stores all raw observable data - Exposes four possible observables: - ``label``: A string passed during construction. - ``independent``: X-axis data (units: \"Independent var (a.u.)\"). - ``dependent``: Y-axis data (units: \"Dependent var (a.u.)\"). - ``datetime``: Extracted from the filename Attributes ---------- label_format : str Datetime formatting string used for timestamp extraction from filenames. dt_pattern : str Regular expression pattern for detecting the encoded timestamp in filenames. _allowed_observables : KeysView Set internally based on ``raw_data`` keys. Used by :meth:`DataCore.get_data`. Usage Notes ----------- This class is commonly paired with :class:`DataProcessor` subclasses and may be used by scatter-based plotters. It is intentionally generic: units and semantic meaning of variables are left to the user or to processing layers. \"\"\" def __init__ ( self , label ): super () . __init__ ( file_reader = read_csv ) self . raw_data = { \"label\" : { \"units\" : \"N/A\" , \"data\" : label }, \"independent\" : None , \"dependent\" : None , \"datetime\" : None , } self . _allowed_observables = self . raw_data . keys () self . label_format = \"%Y_%m_ %d _%H_%M_%S\" self . dt_pattern = '\\d {4} _\\d {2} _\\d {2} _\\d {2} _\\d {2} _\\d {2} ' @with_logging def read_file ( self , filepath : str ): data = self . file_reader ( filepath ) # Assume first two columns are independent and dependent variables if self . raw_data [ 'independent' ] is None : self . raw_data [ 'independent' ] = { \"units\" : \"Independent var (a.u.)\" , \"data\" : data [ '0' ]} if self . raw_data [ 'dependent' ] is None : self . raw_data [ 'dependent' ] = { \"units\" : \"Dependent var (a.u.)\" , \"data\" : data [ '1' ]}","title":"Usage Notes"},{"location":"api/data/scatter_data_processor/","text":"Scatter Data Processor Bases: DataProcessorCore ScatterDataProcessor A lightweight processor for GenericScatterData objects. This class extends DataProcessorCore and provides basic validation of requested observables. For more complex data this class would implement some validation or computation of derived observables. Overview ScatterDataProcessor delegates observable access and unit retrieval to the underlying GenericScatterData instance. It does not compute additional derived quantities as it is not needed; it simply ensures that requested observables can be retrieved. Wraps a GenericScatterData object Validates observable names before use Raises ObservableNotComputableError if a requested observable cannot be obtained Usage Notes This processor is intended for simple scatter-type datasets where only raw observables (e.g., independent , dependent , label , datetime ) are required. Derived or computed observables should be implemented in dedicated processor subclasses. Source code in data\\data_processors\\scatter_data_processor.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ScatterDataProcessor ( DataProcessorCore ): \"\"\" ScatterDataProcessor ==================== A lightweight processor for `GenericScatterData` objects. This class extends `DataProcessorCore` and provides basic validation of requested observables. For more complex data this class would implement some validation or computation of derived observables. Overview -------- `ScatterDataProcessor` delegates observable access and unit retrieval to the underlying `GenericScatterData` instance. It does not compute additional derived quantities as it is not needed; it simply ensures that requested observables can be retrieved. - Wraps a `GenericScatterData` object - Validates observable names before use - Raises `ObservableNotComputableError` if a requested observable cannot be obtained Usage Notes ----------- This processor is intended for simple scatter-type datasets where only raw observables (e.g., *independent*, *dependent*, *label*, *datetime*) are required. Derived or computed observables should be implemented in dedicated processor subclasses. \"\"\" def __init__ ( self , scatter_data : GenericScatterData ): super () . __init__ ( scatter_data ) def validate_observables ( self , * args ): print ( * args ) # Checks whether all desired observables can be obtained for this data try : for observable in args : self . get_data ( observable ) # FIXME: Catchall try-except except : raise ObservableNotComputableError","title":"Scatter Data Processor"},{"location":"api/data/scatter_data_processor/#scatter-data-processor","text":"Bases: DataProcessorCore","title":"Scatter Data Processor"},{"location":"api/data/scatter_data_processor/#data.data_processors.scatter_data_processor.ScatterDataProcessor--scatterdataprocessor","text":"A lightweight processor for GenericScatterData objects. This class extends DataProcessorCore and provides basic validation of requested observables. For more complex data this class would implement some validation or computation of derived observables.","title":"ScatterDataProcessor"},{"location":"api/data/scatter_data_processor/#data.data_processors.scatter_data_processor.ScatterDataProcessor--overview","text":"ScatterDataProcessor delegates observable access and unit retrieval to the underlying GenericScatterData instance. It does not compute additional derived quantities as it is not needed; it simply ensures that requested observables can be retrieved. Wraps a GenericScatterData object Validates observable names before use Raises ObservableNotComputableError if a requested observable cannot be obtained","title":"Overview"},{"location":"api/data/scatter_data_processor/#data.data_processors.scatter_data_processor.ScatterDataProcessor--usage-notes","text":"This processor is intended for simple scatter-type datasets where only raw observables (e.g., independent , dependent , label , datetime ) are required. Derived or computed observables should be implemented in dedicated processor subclasses. Source code in data\\data_processors\\scatter_data_processor.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class ScatterDataProcessor ( DataProcessorCore ): \"\"\" ScatterDataProcessor ==================== A lightweight processor for `GenericScatterData` objects. This class extends `DataProcessorCore` and provides basic validation of requested observables. For more complex data this class would implement some validation or computation of derived observables. Overview -------- `ScatterDataProcessor` delegates observable access and unit retrieval to the underlying `GenericScatterData` instance. It does not compute additional derived quantities as it is not needed; it simply ensures that requested observables can be retrieved. - Wraps a `GenericScatterData` object - Validates observable names before use - Raises `ObservableNotComputableError` if a requested observable cannot be obtained Usage Notes ----------- This processor is intended for simple scatter-type datasets where only raw observables (e.g., *independent*, *dependent*, *label*, *datetime*) are required. Derived or computed observables should be implemented in dedicated processor subclasses. \"\"\" def __init__ ( self , scatter_data : GenericScatterData ): super () . __init__ ( scatter_data ) def validate_observables ( self , * args ): print ( * args ) # Checks whether all desired observables can be obtained for this data try : for observable in args : self . get_data ( observable ) # FIXME: Catchall try-except except : raise ObservableNotComputableError","title":"Usage Notes"},{"location":"api/devices/generic_worker/","text":"Generic Worker Bases: DeviceWorkerCore Generic Device worker for generic scatter-type datasets. This class extends DeviceWorkerCore and wires together the data type, processor, and plotters for simple scatter and histogram visualisations. Overview Generic configures the worker to use: GenericScatterData as the underlying data container ScatterDataProcessor to access and validate observables ScatterDataPlotter for x\u2013y scatter plots HistogramPlotter for value distributions It uses a PlotterOptions instance to control plot appearance, axis titles, and legend labels. Usage Notes Use plot to generate a standard scatter plot of the independent versus dependent observable, and plot_distribution to generate a histogram of the dependent observable across all loaded datasets. Source code in devices\\workers\\generic.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @decorate_class_with_logging ( log_level = DEBUG_WORKER ) class Generic ( DeviceWorkerCore ): \"\"\" Generic ======= Device worker for generic scatter-type datasets. This class extends `DeviceWorkerCore` and wires together the data type, processor, and plotters for simple scatter and histogram visualisations. Overview -------- `Generic` configures the worker to use: - `GenericScatterData` as the underlying data container - `ScatterDataProcessor` to access and validate observables - `ScatterDataPlotter` for x\u2013y scatter plots - `HistogramPlotter` for value distributions It uses a `PlotterOptions` instance to control plot appearance, axis titles, and legend labels. Usage Notes ----------- Use `plot` to generate a standard scatter plot of the *independent* versus *dependent* observable, and `plot_distribution` to generate a histogram of the *dependent* observable across all loaded datasets. \"\"\" def __init__ ( self , device , dataset , plot_type , options : PlotterOptions ): # super() delegates method calls to a parent super () . __init__ ( device , dataset , plot_type , options ) self . x_title = None self . y_title = None self . legend_title = None self . options = options self . data_processors = None self . set_data_type ( GenericScatterData ) self . set_processor_type ( ScatterDataProcessor ) def plot ( self , title ): \"\"\" Show the scatter plot \"\"\" plotter = ScatterDataPlotter ( title , \"independent\" , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"x_title\" ), self . options . get_option ( \"y_title\" )) plotter . draw_plot () def plot_distribution ( self , title ): \"\"\" Show a histogram \"\"\" plotter = HistogramPlotter ( title , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"y_title\" )) plotter . draw_plot () plot ( title ) Show the scatter plot Source code in devices\\workers\\generic.py 51 52 53 54 55 56 57 58 def plot ( self , title ): \"\"\" Show the scatter plot \"\"\" plotter = ScatterDataPlotter ( title , \"independent\" , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"x_title\" ), self . options . get_option ( \"y_title\" )) plotter . draw_plot () plot_distribution ( title ) Show a histogram Source code in devices\\workers\\generic.py 60 61 62 63 64 65 66 67 def plot_distribution ( self , title ): \"\"\" Show a histogram \"\"\" plotter = HistogramPlotter ( title , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"y_title\" )) plotter . draw_plot ()","title":"Generic Worker"},{"location":"api/devices/generic_worker/#generic-worker","text":"Bases: DeviceWorkerCore","title":"Generic Worker"},{"location":"api/devices/generic_worker/#devices.workers.generic.Generic--generic","text":"Device worker for generic scatter-type datasets. This class extends DeviceWorkerCore and wires together the data type, processor, and plotters for simple scatter and histogram visualisations.","title":"Generic"},{"location":"api/devices/generic_worker/#devices.workers.generic.Generic--overview","text":"Generic configures the worker to use: GenericScatterData as the underlying data container ScatterDataProcessor to access and validate observables ScatterDataPlotter for x\u2013y scatter plots HistogramPlotter for value distributions It uses a PlotterOptions instance to control plot appearance, axis titles, and legend labels.","title":"Overview"},{"location":"api/devices/generic_worker/#devices.workers.generic.Generic--usage-notes","text":"Use plot to generate a standard scatter plot of the independent versus dependent observable, and plot_distribution to generate a histogram of the dependent observable across all loaded datasets. Source code in devices\\workers\\generic.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @decorate_class_with_logging ( log_level = DEBUG_WORKER ) class Generic ( DeviceWorkerCore ): \"\"\" Generic ======= Device worker for generic scatter-type datasets. This class extends `DeviceWorkerCore` and wires together the data type, processor, and plotters for simple scatter and histogram visualisations. Overview -------- `Generic` configures the worker to use: - `GenericScatterData` as the underlying data container - `ScatterDataProcessor` to access and validate observables - `ScatterDataPlotter` for x\u2013y scatter plots - `HistogramPlotter` for value distributions It uses a `PlotterOptions` instance to control plot appearance, axis titles, and legend labels. Usage Notes ----------- Use `plot` to generate a standard scatter plot of the *independent* versus *dependent* observable, and `plot_distribution` to generate a histogram of the *dependent* observable across all loaded datasets. \"\"\" def __init__ ( self , device , dataset , plot_type , options : PlotterOptions ): # super() delegates method calls to a parent super () . __init__ ( device , dataset , plot_type , options ) self . x_title = None self . y_title = None self . legend_title = None self . options = options self . data_processors = None self . set_data_type ( GenericScatterData ) self . set_processor_type ( ScatterDataProcessor ) def plot ( self , title ): \"\"\" Show the scatter plot \"\"\" plotter = ScatterDataPlotter ( title , \"independent\" , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"x_title\" ), self . options . get_option ( \"y_title\" )) plotter . draw_plot () def plot_distribution ( self , title ): \"\"\" Show a histogram \"\"\" plotter = HistogramPlotter ( title , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"y_title\" )) plotter . draw_plot ()","title":"Usage Notes"},{"location":"api/devices/generic_worker/#devices.workers.generic.Generic.plot","text":"Show the scatter plot Source code in devices\\workers\\generic.py 51 52 53 54 55 56 57 58 def plot ( self , title ): \"\"\" Show the scatter plot \"\"\" plotter = ScatterDataPlotter ( title , \"independent\" , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"x_title\" ), self . options . get_option ( \"y_title\" )) plotter . draw_plot ()","title":"plot"},{"location":"api/devices/generic_worker/#devices.workers.generic.Generic.plot_distribution","text":"Show a histogram Source code in devices\\workers\\generic.py 60 61 62 63 64 65 66 67 def plot_distribution ( self , title ): \"\"\" Show a histogram \"\"\" plotter = HistogramPlotter ( title , \"dependent\" , self . options ) plotter . ready_plot ( self . data_processors , options = self . options ) plotter . set_axes_titles ( self . options . get_option ( \"y_title\" )) plotter . draw_plot ()","title":"plot_distribution"},{"location":"api/plotters/histogram_plotter/","text":"Histogram Plotter Bases: Plotter HistogramPlotter A Plotly-based histogram plotter for processed observables. This class implements the Plotter interface and visualises a single observable from one or more DataProcessor instances as overlaid histograms. Overview HistogramPlotter : Accepts a dictionary of DataProcessor objects keyed by label Plots a histogram for the chosen observable from each processor Uses PlotterOptions to configure axis titles, legend title, and other layout options Adds a default colourscale to the options for consistent styling The x-axis represents the selected observable, while the y-axis shows the counts in each histogram bin. Usage Notes Call ready_plot with the data processors and options to configure the figure, then call set_axes_titles to customise axis labels if desired. Finally, call draw_plot to render the histogram and show it using the SVG export configuration. Source code in plotters\\histogram_plotter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class HistogramPlotter ( Plotter ): \"\"\" HistogramPlotter ================ A Plotly-based histogram plotter for processed observables. This class implements the `Plotter` interface and visualises a single observable from one or more `DataProcessor` instances as overlaid histograms. Overview -------- `HistogramPlotter`: - Accepts a dictionary of `DataProcessor` objects keyed by label - Plots a histogram for the chosen observable from each processor - Uses `PlotterOptions` to configure axis titles, legend title, and other layout options - Adds a default colourscale to the options for consistent styling The x-axis represents the selected observable, while the y-axis shows the counts in each histogram bin. Usage Notes ----------- Call `ready_plot` with the data processors and options to configure the figure, then call `set_axes_titles` to customise axis labels if desired. Finally, call `draw_plot` to render the histogram and show it using the SVG export configuration. \"\"\" def __init__ ( self , title , observable : str , options : PlotterOptions ): self . titles_set = None self . title = title self . fig = go . Figure () self . observable = observable self . data_processors = None # This is very similar to ScatterPlotter expected_options = [ \"y_title\" , \"legend_title\" , \"presentation\" , \"time_evolved\" ] if options . has_options ( expected_options ): self . options = options self . options . add_option ( label = \"colourscale\" , value = plotly . colors . get_colorscale ( \"Viridis\" )) def ready_plot ( self , data_processors : dict [ str , DataProcessor ], options : PlotterOptions ): self . fig = scatter_prepper ( self . fig ) self . fig . update_layout ( title = { 'text' : self . title }, legend_title = options . get_option ( \"legend_title\" ) ) self . data_processors = data_processors def set_axes_titles ( self , x_title ): self . fig . update_layout ( xaxis_title = x_title , ) self . titles_set = True def draw_plot ( self ): for lbl in self . data_processors : processor = self . data_processors [ lbl ] self . fig . add_trace ( go . Histogram ( x = processor . get_data ( self . observable ), name = processor . get_data ( \"label\" ) ) ) # Grab axis titles from last processor if they have not yet been externally set if not self . titles_set : self . set_axes_titles ( processor . get_units ( self . x_observable ) ) self . fig . update_layout ( yaxis_title = \"$Counts$\" , ) self . fig . show ( config = get_svg_config ())","title":"Histogram Plotter"},{"location":"api/plotters/histogram_plotter/#histogram-plotter","text":"Bases: Plotter","title":"Histogram Plotter"},{"location":"api/plotters/histogram_plotter/#plotters.histogram_plotter.HistogramPlotter--histogramplotter","text":"A Plotly-based histogram plotter for processed observables. This class implements the Plotter interface and visualises a single observable from one or more DataProcessor instances as overlaid histograms.","title":"HistogramPlotter"},{"location":"api/plotters/histogram_plotter/#plotters.histogram_plotter.HistogramPlotter--overview","text":"HistogramPlotter : Accepts a dictionary of DataProcessor objects keyed by label Plots a histogram for the chosen observable from each processor Uses PlotterOptions to configure axis titles, legend title, and other layout options Adds a default colourscale to the options for consistent styling The x-axis represents the selected observable, while the y-axis shows the counts in each histogram bin.","title":"Overview"},{"location":"api/plotters/histogram_plotter/#plotters.histogram_plotter.HistogramPlotter--usage-notes","text":"Call ready_plot with the data processors and options to configure the figure, then call set_axes_titles to customise axis labels if desired. Finally, call draw_plot to render the histogram and show it using the SVG export configuration. Source code in plotters\\histogram_plotter.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class HistogramPlotter ( Plotter ): \"\"\" HistogramPlotter ================ A Plotly-based histogram plotter for processed observables. This class implements the `Plotter` interface and visualises a single observable from one or more `DataProcessor` instances as overlaid histograms. Overview -------- `HistogramPlotter`: - Accepts a dictionary of `DataProcessor` objects keyed by label - Plots a histogram for the chosen observable from each processor - Uses `PlotterOptions` to configure axis titles, legend title, and other layout options - Adds a default colourscale to the options for consistent styling The x-axis represents the selected observable, while the y-axis shows the counts in each histogram bin. Usage Notes ----------- Call `ready_plot` with the data processors and options to configure the figure, then call `set_axes_titles` to customise axis labels if desired. Finally, call `draw_plot` to render the histogram and show it using the SVG export configuration. \"\"\" def __init__ ( self , title , observable : str , options : PlotterOptions ): self . titles_set = None self . title = title self . fig = go . Figure () self . observable = observable self . data_processors = None # This is very similar to ScatterPlotter expected_options = [ \"y_title\" , \"legend_title\" , \"presentation\" , \"time_evolved\" ] if options . has_options ( expected_options ): self . options = options self . options . add_option ( label = \"colourscale\" , value = plotly . colors . get_colorscale ( \"Viridis\" )) def ready_plot ( self , data_processors : dict [ str , DataProcessor ], options : PlotterOptions ): self . fig = scatter_prepper ( self . fig ) self . fig . update_layout ( title = { 'text' : self . title }, legend_title = options . get_option ( \"legend_title\" ) ) self . data_processors = data_processors def set_axes_titles ( self , x_title ): self . fig . update_layout ( xaxis_title = x_title , ) self . titles_set = True def draw_plot ( self ): for lbl in self . data_processors : processor = self . data_processors [ lbl ] self . fig . add_trace ( go . Histogram ( x = processor . get_data ( self . observable ), name = processor . get_data ( \"label\" ) ) ) # Grab axis titles from last processor if they have not yet been externally set if not self . titles_set : self . set_axes_titles ( processor . get_units ( self . x_observable ) ) self . fig . update_layout ( yaxis_title = \"$Counts$\" , ) self . fig . show ( config = get_svg_config ())","title":"Usage Notes"},{"location":"api/plotters/scatter_data_plotter/","text":"Scatter Data Plotter Bases: Plotter ScatterDataPlotter A Plotly-based line scatter plotter for generic x\u2013y datasets. This class implements the Plotter interface and draws one or more traces from DataProcessor instances. Overview ScatterDataPlotter : Plots a chosen x observable versus a chosen y observable Accepts a dictionary of DataProcessor objects keyed by label Uses PlotterOptions to set axis titles, legend title, and line styling Supports a \"presentation\" mode with thicker lines Supports \"time_evolved\" plots by switching to a different colourscale Each trace is assigned a colour from the configured colourscale based on its index, and is plotted as a continuous line. Usage Notes Call ready_plot to prepare the figure and configure options, then optionally call set_axes_titles to override axis labels. Finally, call draw_plot to add all traces and display the figure using the SVG export configuration. Source code in plotters\\scatter_data_plotter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class ScatterDataPlotter ( Plotter ): \"\"\" ScatterDataPlotter ================== A Plotly-based line scatter plotter for generic x\u2013y datasets. This class implements the `Plotter` interface and draws one or more traces from `DataProcessor` instances. Overview -------- `ScatterDataPlotter`: - Plots a chosen x observable versus a chosen y observable - Accepts a dictionary of `DataProcessor` objects keyed by label - Uses `PlotterOptions` to set axis titles, legend title, and line styling - Supports a \"presentation\" mode with thicker lines - Supports \"time_evolved\" plots by switching to a different colourscale Each trace is assigned a colour from the configured colourscale based on its index, and is plotted as a continuous line. Usage Notes ----------- Call `ready_plot` to prepare the figure and configure options, then optionally call `set_axes_titles` to override axis labels. Finally, call `draw_plot` to add all traces and display the figure using the SVG export configuration. \"\"\" def __init__ ( self , title , x_observable : str , y_observable : str , options : PlotterOptions ): self . title = title self . fig = go . Figure () self . x_observable = x_observable self . y_observable = y_observable self . data_processors = None self . titles_set = False self . sort_x_array = False expected_options = [ \"x_title\" , \"y_title\" , \"legend_title\" , \"presentation\" , \"time_evolved\" ] if options . has_options ( expected_options ): self . options = options options . add_option ( label = \"colourscale\" , value = plotly . colors . get_colorscale ( \"Viridis\" )) def ready_plot ( self , data_processors : dict [ str , DataProcessor ], options : PlotterOptions ): self . fig = scatter_prepper ( self . fig ) self . fig . update_layout ( title = { 'text' : self . title }, legend_title = self . options . get_option ( \"legend_title\" ), ) self . data_processors = data_processors # Line should be thicker for presentations if self . options . get_option ( \"presentation\" ): self . options . add_option ( label = \"line\" , value = { \"width\" : 5 }) else : self . options . add_option ( label = \"line\" , value = { \"width\" : 1 }) # Set colourscale for the continuous time evolved data if self . options . get_option ( \"time_evolved\" ): self . options . update_option ( label = \"colourscale\" , value = plotly . colors . get_colorscale ( \"Magenta\" )) # Gets called by draw_plot to populate with data units if not manually set def set_axes_titles ( self , x_title , y_title ): self . fig . update_layout ( xaxis_title = x_title , yaxis_title = y_title , ) self . titles_set = True def draw_plot ( self , * args , ** kwargs ): # FEATURE REQUEST: Draw plots with errors for index , lbl in enumerate ( self . data_processors ): # Set line colour for current line line = self . options . get_option ( \"line\" ) line [ \"color\" ] = get_plotly_colour ( self . options . get_option ( \"colourscale\" ), index / len ( self . data_processors )) self . options . add_option ( \"line\" , line ) # Grab and plot data scatter = self . data_processors [ lbl ] self . fig . add_trace ( go . Scatter ( x = scatter . get_data ( self . x_observable , * args , ** kwargs ), y = scatter . get_data ( self . y_observable , * args , ** kwargs ), mode = 'lines' , name = scatter . get_data ( 'label' ), line = line )) # Grab axis titles from last IVData if they have not yet been externally set if not self . titles_set : self . set_axes_titles ( scatter . get_units ( self . x_observable ), scatter . get_units ( self . y_observable ) ) self . fig . show ( config = get_svg_config ())","title":"Scatter Data Plotter"},{"location":"api/plotters/scatter_data_plotter/#scatter-data-plotter","text":"Bases: Plotter","title":"Scatter Data Plotter"},{"location":"api/plotters/scatter_data_plotter/#plotters.scatter_data_plotter.ScatterDataPlotter--scatterdataplotter","text":"A Plotly-based line scatter plotter for generic x\u2013y datasets. This class implements the Plotter interface and draws one or more traces from DataProcessor instances.","title":"ScatterDataPlotter"},{"location":"api/plotters/scatter_data_plotter/#plotters.scatter_data_plotter.ScatterDataPlotter--overview","text":"ScatterDataPlotter : Plots a chosen x observable versus a chosen y observable Accepts a dictionary of DataProcessor objects keyed by label Uses PlotterOptions to set axis titles, legend title, and line styling Supports a \"presentation\" mode with thicker lines Supports \"time_evolved\" plots by switching to a different colourscale Each trace is assigned a colour from the configured colourscale based on its index, and is plotted as a continuous line.","title":"Overview"},{"location":"api/plotters/scatter_data_plotter/#plotters.scatter_data_plotter.ScatterDataPlotter--usage-notes","text":"Call ready_plot to prepare the figure and configure options, then optionally call set_axes_titles to override axis labels. Finally, call draw_plot to add all traces and display the figure using the SVG export configuration. Source code in plotters\\scatter_data_plotter.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @decorate_class_with_logging ( log_level = DEBUG_PLOTTER ) class ScatterDataPlotter ( Plotter ): \"\"\" ScatterDataPlotter ================== A Plotly-based line scatter plotter for generic x\u2013y datasets. This class implements the `Plotter` interface and draws one or more traces from `DataProcessor` instances. Overview -------- `ScatterDataPlotter`: - Plots a chosen x observable versus a chosen y observable - Accepts a dictionary of `DataProcessor` objects keyed by label - Uses `PlotterOptions` to set axis titles, legend title, and line styling - Supports a \"presentation\" mode with thicker lines - Supports \"time_evolved\" plots by switching to a different colourscale Each trace is assigned a colour from the configured colourscale based on its index, and is plotted as a continuous line. Usage Notes ----------- Call `ready_plot` to prepare the figure and configure options, then optionally call `set_axes_titles` to override axis labels. Finally, call `draw_plot` to add all traces and display the figure using the SVG export configuration. \"\"\" def __init__ ( self , title , x_observable : str , y_observable : str , options : PlotterOptions ): self . title = title self . fig = go . Figure () self . x_observable = x_observable self . y_observable = y_observable self . data_processors = None self . titles_set = False self . sort_x_array = False expected_options = [ \"x_title\" , \"y_title\" , \"legend_title\" , \"presentation\" , \"time_evolved\" ] if options . has_options ( expected_options ): self . options = options options . add_option ( label = \"colourscale\" , value = plotly . colors . get_colorscale ( \"Viridis\" )) def ready_plot ( self , data_processors : dict [ str , DataProcessor ], options : PlotterOptions ): self . fig = scatter_prepper ( self . fig ) self . fig . update_layout ( title = { 'text' : self . title }, legend_title = self . options . get_option ( \"legend_title\" ), ) self . data_processors = data_processors # Line should be thicker for presentations if self . options . get_option ( \"presentation\" ): self . options . add_option ( label = \"line\" , value = { \"width\" : 5 }) else : self . options . add_option ( label = \"line\" , value = { \"width\" : 1 }) # Set colourscale for the continuous time evolved data if self . options . get_option ( \"time_evolved\" ): self . options . update_option ( label = \"colourscale\" , value = plotly . colors . get_colorscale ( \"Magenta\" )) # Gets called by draw_plot to populate with data units if not manually set def set_axes_titles ( self , x_title , y_title ): self . fig . update_layout ( xaxis_title = x_title , yaxis_title = y_title , ) self . titles_set = True def draw_plot ( self , * args , ** kwargs ): # FEATURE REQUEST: Draw plots with errors for index , lbl in enumerate ( self . data_processors ): # Set line colour for current line line = self . options . get_option ( \"line\" ) line [ \"color\" ] = get_plotly_colour ( self . options . get_option ( \"colourscale\" ), index / len ( self . data_processors )) self . options . add_option ( \"line\" , line ) # Grab and plot data scatter = self . data_processors [ lbl ] self . fig . add_trace ( go . Scatter ( x = scatter . get_data ( self . x_observable , * args , ** kwargs ), y = scatter . get_data ( self . y_observable , * args , ** kwargs ), mode = 'lines' , name = scatter . get_data ( 'label' ), line = line )) # Grab axis titles from last IVData if they have not yet been externally set if not self . titles_set : self . set_axes_titles ( scatter . get_units ( self . x_observable ), scatter . get_units ( self . y_observable ) ) self . fig . show ( config = get_svg_config ())","title":"Usage Notes"},{"location":"api/utils/export_to_svg/","text":"Export to SVG Makes sure to export plots as vector graphics. Note: It is important to note that any figures containing WebGL traces (i.e. of type scattergl, heatmapgl, contourgl, scatter3d, surface, mesh3d, scatterpolargl, cone, streamtube, splom, or parcoords) that are exported in a vector format will include encapsulated rasters, instead of vectors, for some parts of the image. (see https://plotly.com/python/static-image-export/#vector-formats-svg-and-pdf) Source code in utils\\plot_preppers\\export_to_svg.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def get_svg_config ( filename : str = 'custom_image' ) -> dict : \"\"\" Makes sure to export plots as vector graphics. Note: It is important to note that any figures containing WebGL traces (i.e. of type scattergl, heatmapgl, contourgl, scatter3d, surface, mesh3d, scatterpolargl, cone, streamtube, splom, or parcoords) that are exported in a vector format will include encapsulated rasters, instead of vectors, for some parts of the image. (see https://plotly.com/python/static-image-export/#vector-formats-svg-and-pdf) \"\"\" config = { 'toImageButtonOptions' : { 'format' : 'svg' , # Save as SVG 'filename' : filename , 'scale' : 1 , 'width' : 1920 , # 1080p width 'height' : 1080 # 1080p height (16:9 aspect ratio) } } return config","title":"Export to SVG"},{"location":"api/utils/export_to_svg/#export-to-svg","text":"Makes sure to export plots as vector graphics. Note: It is important to note that any figures containing WebGL traces (i.e. of type scattergl, heatmapgl, contourgl, scatter3d, surface, mesh3d, scatterpolargl, cone, streamtube, splom, or parcoords) that are exported in a vector format will include encapsulated rasters, instead of vectors, for some parts of the image. (see https://plotly.com/python/static-image-export/#vector-formats-svg-and-pdf) Source code in utils\\plot_preppers\\export_to_svg.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def get_svg_config ( filename : str = 'custom_image' ) -> dict : \"\"\" Makes sure to export plots as vector graphics. Note: It is important to note that any figures containing WebGL traces (i.e. of type scattergl, heatmapgl, contourgl, scatter3d, surface, mesh3d, scatterpolargl, cone, streamtube, splom, or parcoords) that are exported in a vector format will include encapsulated rasters, instead of vectors, for some parts of the image. (see https://plotly.com/python/static-image-export/#vector-formats-svg-and-pdf) \"\"\" config = { 'toImageButtonOptions' : { 'format' : 'svg' , # Save as SVG 'filename' : filename , 'scale' : 1 , 'width' : 1920 , # 1080p width 'height' : 1080 # 1080p height (16:9 aspect ratio) } } return config","title":"Export to SVG"},{"location":"api/utils/get_colour/","text":"Get Colour Detect colourscale type based on structure. This function assumed discrete scales to be lists of colours and thus flat while continous scales are assumed to be a list of tuples containing some value and the associated colour. Source code in utils\\plotly_colour_helpers\\get_plotly_colour.py 5 6 7 8 9 10 11 12 13 14 15 16 17 def get_plotly_colour ( colorscale , value ): \"\"\" Detect colourscale type based on structure. This function assumed discrete scales to be lists of colours and thus flat while continous scales are assumed to be a list of tuples containing some value and the associated colour. \"\"\" # Determine if colorscale is continuous (nested list) or discrete (flat list) is_continuous = isinstance ( colorscale [ 0 ], ( list , tuple )) and len ( colorscale [ 0 ]) == 2 if is_continuous : return get_continuous_colour ( colorscale , value ) else : return get_discrete_colour ( colorscale , value )","title":"Get Colour"},{"location":"api/utils/get_colour/#get-colour","text":"Detect colourscale type based on structure. This function assumed discrete scales to be lists of colours and thus flat while continous scales are assumed to be a list of tuples containing some value and the associated colour. Source code in utils\\plotly_colour_helpers\\get_plotly_colour.py 5 6 7 8 9 10 11 12 13 14 15 16 17 def get_plotly_colour ( colorscale , value ): \"\"\" Detect colourscale type based on structure. This function assumed discrete scales to be lists of colours and thus flat while continous scales are assumed to be a list of tuples containing some value and the associated colour. \"\"\" # Determine if colorscale is continuous (nested list) or discrete (flat list) is_continuous = isinstance ( colorscale [ 0 ], ( list , tuple )) and len ( colorscale [ 0 ]) == 2 if is_continuous : return get_continuous_colour ( colorscale , value ) else : return get_discrete_colour ( colorscale , value )","title":"Get Colour"},{"location":"api/utils/read_table_csv/","text":"Read Table CSV FileReaderFn-compatible CSV/table reader. Behaviour Excel (.xls/.xlsx): Read with header=None. Apply header heuristic: First row all numeric -> column keys: \"0\", \"1\", ... Otherwise -> first row used as header strings. Text files: Read full file as text. Case-insensitive 'end data' splits data vs metadata: Data before 'end data' Metadata after, parsed as \"key: value\" Data block parsed via pandas.read_csv with whitespace delimiter. On failure, fallback to csv.reader using the same data lines. Output: Each column under a string key (header-or-index). Metadata dict (if any) under key \"meta\". Source code in utils\\file_readers\\read_table_csv.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def read_csv ( path : str ) -> ReaderOutput : \"\"\" FileReaderFn-compatible CSV/table reader. Behaviour: - Excel (.xls/.xlsx): * Read with header=None. * Apply header heuristic: - First row all numeric -> column keys: \"0\", \"1\", ... - Otherwise -> first row used as header strings. - Text files: * Read full file as text. * Case-insensitive 'end data' splits data vs metadata: - Data before 'end data' - Metadata after, parsed as \"key: value\" * Data block parsed via pandas.read_csv with whitespace delimiter. * On failure, fallback to csv.reader using the same data lines. - Output: * Each column under a string key (header-or-index). * Metadata dict (if any) under key \"meta\". \"\"\" # -------- Excel handling -------- if path . lower () . endswith (( \".xls\" , \".xlsx\" )): # Read EVERYTHING as data; decide header ourselves. df = pd . read_excel ( path , header = None ) df = _apply_header_heuristic ( df ) output : Dict [ str , Any ] = {} for col in df . columns : series = df [ col ] . astype ( str ) . str . replace ( \",\" , \".\" ) numeric = pd . to_numeric ( series , errors = \"ignore\" ) output [ str ( col )] = numeric . tolist () return output # -------- Text file handling -------- with open ( path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () lower = content . lower () marker = \"end data\" meta_dict : Dict [ str , str ] = {} # Split into data and metadata (case-insensitive marker) if marker in lower : idx = lower . index ( marker ) data_part = content [: idx ] # preserve original case meta_part = content [ idx + len ( marker ):] # preserve original case data_lines = [ ln for ln in data_part . splitlines () if ln . strip ()] for line in meta_part . splitlines (): if \":\" in line : key , value = line . split ( \":\" , 1 ) meta_dict [ key . strip ()] = value . strip () else : data_lines = [ ln for ln in content . splitlines () if ln . strip ()] # FileReaderFn(path) has no skip_lines argument, so we fix it at 0 here. skip_lines = 0 effective_lines = data_lines [ skip_lines :] # -------- Try pandas first -------- try : df = pd . read_csv ( StringIO ( \" \\n \" . join ( effective_lines )), delim_whitespace = True , na_values = [ \"NaN\" ], engine = \"python\" , header = None , # we handle header manually ) except Exception : # -------- Fallback: csv.reader on same lines -------- text = \" \\n \" . join ( effective_lines ) # Try to sniff delimiter on the data block try : sample = text [: 2048 ] dialect = csv . Sniffer () . sniff ( sample ) delimiter = dialect . delimiter except csv . Error : delimiter = \",\" reader = csv . reader ( StringIO ( text ), delimiter = delimiter ) rows = [ row for row in reader if row ] df = pd . DataFrame ( rows ) # Apply header heuristic df = _apply_header_heuristic ( df ) # -------- Build ReaderOutput -------- output : Dict [ str , Any ] = {} for col in df . columns : series = df [ col ] . astype ( str ) . str . replace ( \",\" , \".\" ) numeric = pd . to_numeric ( series , errors = \"ignore\" ) output [ str ( col )] = numeric . tolist () if meta_dict : output [ \"meta\" ] = meta_dict return output","title":"Read Table CSV"},{"location":"api/utils/read_table_csv/#read-table-csv","text":"FileReaderFn-compatible CSV/table reader. Behaviour Excel (.xls/.xlsx): Read with header=None. Apply header heuristic: First row all numeric -> column keys: \"0\", \"1\", ... Otherwise -> first row used as header strings. Text files: Read full file as text. Case-insensitive 'end data' splits data vs metadata: Data before 'end data' Metadata after, parsed as \"key: value\" Data block parsed via pandas.read_csv with whitespace delimiter. On failure, fallback to csv.reader using the same data lines. Output: Each column under a string key (header-or-index). Metadata dict (if any) under key \"meta\". Source code in utils\\file_readers\\read_table_csv.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 def read_csv ( path : str ) -> ReaderOutput : \"\"\" FileReaderFn-compatible CSV/table reader. Behaviour: - Excel (.xls/.xlsx): * Read with header=None. * Apply header heuristic: - First row all numeric -> column keys: \"0\", \"1\", ... - Otherwise -> first row used as header strings. - Text files: * Read full file as text. * Case-insensitive 'end data' splits data vs metadata: - Data before 'end data' - Metadata after, parsed as \"key: value\" * Data block parsed via pandas.read_csv with whitespace delimiter. * On failure, fallback to csv.reader using the same data lines. - Output: * Each column under a string key (header-or-index). * Metadata dict (if any) under key \"meta\". \"\"\" # -------- Excel handling -------- if path . lower () . endswith (( \".xls\" , \".xlsx\" )): # Read EVERYTHING as data; decide header ourselves. df = pd . read_excel ( path , header = None ) df = _apply_header_heuristic ( df ) output : Dict [ str , Any ] = {} for col in df . columns : series = df [ col ] . astype ( str ) . str . replace ( \",\" , \".\" ) numeric = pd . to_numeric ( series , errors = \"ignore\" ) output [ str ( col )] = numeric . tolist () return output # -------- Text file handling -------- with open ( path , \"r\" , encoding = \"utf-8\" ) as f : content = f . read () lower = content . lower () marker = \"end data\" meta_dict : Dict [ str , str ] = {} # Split into data and metadata (case-insensitive marker) if marker in lower : idx = lower . index ( marker ) data_part = content [: idx ] # preserve original case meta_part = content [ idx + len ( marker ):] # preserve original case data_lines = [ ln for ln in data_part . splitlines () if ln . strip ()] for line in meta_part . splitlines (): if \":\" in line : key , value = line . split ( \":\" , 1 ) meta_dict [ key . strip ()] = value . strip () else : data_lines = [ ln for ln in content . splitlines () if ln . strip ()] # FileReaderFn(path) has no skip_lines argument, so we fix it at 0 here. skip_lines = 0 effective_lines = data_lines [ skip_lines :] # -------- Try pandas first -------- try : df = pd . read_csv ( StringIO ( \" \\n \" . join ( effective_lines )), delim_whitespace = True , na_values = [ \"NaN\" ], engine = \"python\" , header = None , # we handle header manually ) except Exception : # -------- Fallback: csv.reader on same lines -------- text = \" \\n \" . join ( effective_lines ) # Try to sniff delimiter on the data block try : sample = text [: 2048 ] dialect = csv . Sniffer () . sniff ( sample ) delimiter = dialect . delimiter except csv . Error : delimiter = \",\" reader = csv . reader ( StringIO ( text ), delimiter = delimiter ) rows = [ row for row in reader if row ] df = pd . DataFrame ( rows ) # Apply header heuristic df = _apply_header_heuristic ( df ) # -------- Build ReaderOutput -------- output : Dict [ str , Any ] = {} for col in df . columns : series = df [ col ] . astype ( str ) . str . replace ( \",\" , \".\" ) numeric = pd . to_numeric ( series , errors = \"ignore\" ) output [ str ( col )] = numeric . tolist () if meta_dict : output [ \"meta\" ] = meta_dict return output","title":"Read Table CSV"},{"location":"api/utils/scatter_prep/","text":"Scatter Prep Apply standard formatting to a Plotly scatter Figure. This helper function configures a scatter plot figure with a consistent visual style suitable for publication-quality plots and use within the X-LAB Plotting GUI. It adjusts title placement, font settings, axis appearance, and grid visibility. The following changes are applied: - Centers the main title and positions it slightly below the top of the figure. - Sets a uniform font family and size for the figure. - Formats x and y axes with visible outer lines, ticks on the outside, and no top/right spines. - Ensures axis ticks point outward and are clearly visible. - Removes all grid lines from both axes for a clean look. Parameters fig : go.Figure A Plotly Figure instance containing scatter traces to be styled. Returns go.Figure The same Figure instance with updated layout and axes styling. Source code in utils\\plot_preppers\\scatter_prep.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def scatter_prepper ( fig : go . Figure ) -> go . Figure : \"\"\" Apply standard formatting to a Plotly scatter Figure. This helper function configures a scatter plot figure with a consistent visual style suitable for publication-quality plots and use within the X-LAB Plotting GUI. It adjusts title placement, font settings, axis appearance, and grid visibility. The following changes are applied: - Centers the main title and positions it slightly below the top of the figure. - Sets a uniform font family and size for the figure. - Formats x and y axes with visible outer lines, ticks on the outside, and no top/right spines. - Ensures axis ticks point outward and are clearly visible. - Removes all grid lines from both axes for a clean look. Parameters ---------- fig : go.Figure A Plotly ``Figure`` instance containing scatter traces to be styled. Returns ------- go.Figure The same ``Figure`` instance with updated layout and axes styling. \"\"\" # Format title fig . update_layout ( title = { 'y' : 0.9 , 'x' : 0.5 , 'xanchor' : 'center' , 'yanchor' : 'top' }, ) # Format font fig . update_layout ( font = dict ( family = \"Open Sans\" , size = 18 , color = \"RebeccaPurple\" ), ) # Format background colours fig . update_layout ( paper_bgcolor = 'rgba(0,0,0,0)' , plot_bgcolor = 'rgba(0,0,0,0)' ) # Format axes fig . update_xaxes ( showline = True , linewidth = 2 , linecolor = 'black' , ticks = \"outside\" ) fig . update_yaxes ( showline = True , linewidth = 2 , linecolor = 'black' , ticks = \"outside\" ) # No Grid fig . update_xaxes ( showgrid = False ) fig . update_yaxes ( showgrid = False ) return fig","title":"Scatter Prep"},{"location":"api/utils/scatter_prep/#scatter-prep","text":"Apply standard formatting to a Plotly scatter Figure. This helper function configures a scatter plot figure with a consistent visual style suitable for publication-quality plots and use within the X-LAB Plotting GUI. It adjusts title placement, font settings, axis appearance, and grid visibility. The following changes are applied: - Centers the main title and positions it slightly below the top of the figure. - Sets a uniform font family and size for the figure. - Formats x and y axes with visible outer lines, ticks on the outside, and no top/right spines. - Ensures axis ticks point outward and are clearly visible. - Removes all grid lines from both axes for a clean look.","title":"Scatter Prep"},{"location":"api/utils/scatter_prep/#utils.plot_preppers.scatter_prep.scatter_prepper--parameters","text":"fig : go.Figure A Plotly Figure instance containing scatter traces to be styled.","title":"Parameters"},{"location":"api/utils/scatter_prep/#utils.plot_preppers.scatter_prep.scatter_prepper--returns","text":"go.Figure The same Figure instance with updated layout and axes styling. Source code in utils\\plot_preppers\\scatter_prep.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def scatter_prepper ( fig : go . Figure ) -> go . Figure : \"\"\" Apply standard formatting to a Plotly scatter Figure. This helper function configures a scatter plot figure with a consistent visual style suitable for publication-quality plots and use within the X-LAB Plotting GUI. It adjusts title placement, font settings, axis appearance, and grid visibility. The following changes are applied: - Centers the main title and positions it slightly below the top of the figure. - Sets a uniform font family and size for the figure. - Formats x and y axes with visible outer lines, ticks on the outside, and no top/right spines. - Ensures axis ticks point outward and are clearly visible. - Removes all grid lines from both axes for a clean look. Parameters ---------- fig : go.Figure A Plotly ``Figure`` instance containing scatter traces to be styled. Returns ------- go.Figure The same ``Figure`` instance with updated layout and axes styling. \"\"\" # Format title fig . update_layout ( title = { 'y' : 0.9 , 'x' : 0.5 , 'xanchor' : 'center' , 'yanchor' : 'top' }, ) # Format font fig . update_layout ( font = dict ( family = \"Open Sans\" , size = 18 , color = \"RebeccaPurple\" ), ) # Format background colours fig . update_layout ( paper_bgcolor = 'rgba(0,0,0,0)' , plot_bgcolor = 'rgba(0,0,0,0)' ) # Format axes fig . update_xaxes ( showline = True , linewidth = 2 , linecolor = 'black' , ticks = \"outside\" ) fig . update_yaxes ( showline = True , linewidth = 2 , linecolor = 'black' , ticks = \"outside\" ) # No Grid fig . update_xaxes ( showgrid = False ) fig . update_yaxes ( showgrid = False ) return fig","title":"Returns"}]}